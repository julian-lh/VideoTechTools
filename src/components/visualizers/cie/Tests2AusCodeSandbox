import * as THREE from 'three'
import ReactDOM from 'react-dom'
import React, { useRef, useMemo, useState, useEffect } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import niceColors from 'nice-color-palettes'
import Effects from './Effects'
import './styles.css'
import { generateYxy3dCoordinates, generateRGB3dCoordinates } from './signalGenerator'

//const signalxyY = generateYxy3dCoordinates('709');
const tempObject = new THREE.Object3D()
const tempColor = new THREE.Color()
const colors = new Array(1000).fill().map(() => niceColors[17][Math.floor(Math.random() * 5)])
//console.log(niceColors[17])
function Boxes() {
  const [hovered, set] = useState()
  const colorArray = useMemo(() => Float32Array.from(new Array(1000).fill().flatMap((_, i) => tempColor.set(colors[i]).toArray())), [])
  const signalxyY = useMemo( () => generateRGB3dCoordinates('709'), []);
  const meshRef = useRef()
  const prevRef = useRef()
  //useEffect(() => void (prevRef.current = hovered), [hovered])
  useFrame((state) => {
    const time = state.clock.getElapsedTime()
    meshRef.current.rotation.x = Math.sin(time / 4)
    meshRef.current.rotation.y = Math.sin(time / 2)
    /*
    for (let i = 0; i <= signalxyY.flat(1).length; i++){
      const xyY = signalxyY.flat(1)[i];
      tempObject.position.set(xyY[0], xyY[1], xyY[2]);
      tempObject.rotation.y = Math.sin(1 + time)
      tempColor.set('green').toArray(colorArray, (i+1) * 3)
      meshRef.current.geometry.attributes.color.needsUpdate = true;
      tempObject.updateMatrix();
      meshRef.current.setMatrixAt(i+1, tempObject.matrix);
    }
    meshRef.current.instanceMatrix.needsUpdate = true;*/


    let i = 0
    //let z = 0
    //let y = 0
    //for (let x = 0; x < 10; x++)
      //for (let y = 0; y < 10; y++)
        for (let x = 0; x < signalxyY.flat(1).length; x++) {
          const id = i++;
          const xyY = signalxyY.flat(1)[id];
          tempObject.position.set(xyY[0] - 0.5, xyY[1] - 0.5, xyY[2] - 0.5)
          //tempObject.rotation.y = Math.sin(x / 4 + time) + Math.sin(y / 4 + time) + Math.sin(z / 4 + time)
          //tempObject.rotation.z = tempObject.rotation.y * 2
          //if (hovered !== prevRef.Current) {
            //tempColor.set(id === hovered ? 'white' : colors[id]).toArray(colorArray, id * 3)
            //console.log(3)
            const clr = xyY.map((f) => (f * 15).toString(16));
            tempColor.set("#"+clr[0]+clr[1]+clr[2]).toArray(colorArray, id * 3)
            meshRef.current.geometry.attributes.color.needsUpdate = true
          //}
          const scale = id === hovered ? 2 : 1
          tempObject.scale.set(scale, scale, scale)
          tempObject.updateMatrix()
          meshRef.current.setMatrixAt(id, tempObject.matrix)
        }
    meshRef.current.instanceMatrix.needsUpdate = true
  })
  return (
    <instancedMesh ref={meshRef} args={[null, null, signalxyY.flat(1).length]} >
      <boxGeometry args={[0.01, 0.01, 0.01]}>
        <instancedBufferAttribute attachObject={['attributes', 'color']} args={[colorArray, 3]} />
      </boxGeometry>
      <meshBasicMaterial vertexColors={THREE.VertexColors} />
    </instancedMesh>
  )
}

ReactDOM.render(
  <Canvas
    flat
    gl={{ antialias: false, alpha: false }}
    camera={{ position: [1.1, 1.1, 1.1], near: 0.1, far: 3 }}
    onCreated={({ gl }) => gl.setClearColor('#000')}>
    <Boxes />
    <Effects />
  </Canvas>,
  document.getElementById('root')
)
